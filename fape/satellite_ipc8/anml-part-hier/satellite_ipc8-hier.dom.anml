 
type direction;
type mode;
type powerable;
type satellite < powerable with {
    variable direction pointing;
    variable powerable powered;
};

predicate have_image(direction d, mode m);

type instrument < powerable with {
    constant satellite on_board;
    constant boolean supports(mode m);
    predicate power_on();
    predicate calibrated();
    constant boolean calibration_target(direction d);
};

action turn_to(satellite s, direction d_new) {
//    motivated;

    duration := 5;
//    :decomposition {
        constant direction d_prev;
	d_new != d_prev;	 
    	[all] s.pointing == d_prev :-> d_new;
//    };
//    :decomposition{
//      [all] s.pointing == d_new;
//    };
};

action switch_on(instrument i, satellite s) {
    motivated;
    duration := 2;
    i.on_board == s;
    [all] s.powered == s :-> i;
    [start] i.calibrated := false;
};


action switch_off(instrument i, satellite s) {
    motivated;
    duration := 1;
    i.on_board == s;
    [all] s.powered == i :-> s;
};

action calibrate(satellite s, instrument i) {
    motivated;
    duration := 5;
    constant direction d;
    i.on_board == s;
    i.calibration_target(d);
    [all] s.pointing == d;
    [all] s.powered == i;
    [all] i.calibrated == false :-> true;

//    [t1,t2] turn_to(s, d);
//    t2 < start;
};


action use(instrument i, satellite s) {
  motivated;
  i.on_board == s;
  :decomposition{
    
  };
  :decomposition{
    [start,t1] switch_on(i, s);
    [t3+1,t5] calibrate(s, i);
    [t2, end] switch_off(i,s);
    t5 < t2;
  };
};

// action take_image(satellite s, direction d, instrument i, mode m) {
//     duration := 7;
//     i.on_board == s;
//     i.supports(m);
//     [all] i.calibrated == true;
//     [all] s.powered == i;
//     [all] s.pointing == d;
//     [end] have_image(d, m) := true;
// };

action take_image(direction d, mode m) {
    motivated;
    constant satellite s;
    constant instrument i;
    duration := 7;
    i.on_board == s;
    i.supports(m);
    [all] i.calibrated == true;
    [all] s.powered == i;
    [all] s.pointing == d;

//    [t1,t2] turn_to(s, d);
//    t2 < start;
};

